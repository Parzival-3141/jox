using System;
using System.Collections.Generic;
using System.IO;

namespace AST_Code_Generator
{
    //  Example code
    //public interface IExpr
    //{
    //    public interface IVisitor<T>
    //    {
    //        T VisitBinaryExpr(Binary expr);
    //    }

    //    T Accept<T>(IVisitor<T> visitor);

    //    public struct Binary : IExpr
    //    {
    //        public readonly IExpr left;
    //        public readonly object @operator;
    //        public readonly IExpr right;

    //        public Binary(IExpr left, object @operator, IExpr right)
    //        {
    //            this.left = left;
    //            this.@operator = @operator;
    //            this.right = right;
    //        }

    //        public T Accept<T>(IVisitor<T> visitor)
    //        {
    //            return visitor.VisitBinaryExpr(this);
    //        }
    //    }
    //}



    static class Generator
    {
        const string TAB = @"    ";
        const string TAB2 = TAB + TAB;
        const string TAB3 = TAB2 + TAB;
        const string TAB4 = TAB2 + TAB2;

        const string VISITOR_FUNC = "T Accept<T>(IVisitor<T> visitor)";

        const string GEN_WARNING =
@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------";


        const string USINGS = "using System;\nusing System.Collections.Generic;";

        static HashSet<(string baseName, string[] types)> ASTDefs = new()
        {
            ( "Expr", new string[]
                {
                    "Assign   : Token ident, Expr value",
                    "Binary   : Expr left, Token @operator, Expr right",
                    "Grouping : Expr expression",
                    "Literal  : Object value",
                    "Unary    : Token @operator, Expr right",
                    "Variable : Token ident",
                }
            ),

            ( "Stmt", new string[]
                {
                    "Expression : Expr expression",
                    "Print      : Expr expression",
                    "Var        : Token ident, Expr initializer",
                    "Block      : List<Stmt> statements",
                }
            )
        };

        static void Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: ast-gen <output-directory>");
                Environment.Exit(1);
            }

            foreach (var ast in ASTDefs)
                DefineAST(args[0], ast);

            Console.WriteLine("Completed!");
        }

        static void DefineAST(string outputDir, (string baseName, string[] types) ast)
        {
            string path = Path.Join(outputDir, "I" + ast.baseName + ".cs");
            Directory.CreateDirectory(outputDir);

            using StreamWriter sw = File.CreateText(path);

            sw.WriteLine(GEN_WARNING);
            sw.WriteLine();
            
            sw.WriteLine(USINGS);
            sw.WriteLine();
            
            sw.WriteLine("namespace Jox.Parsing.AST");
            sw.WriteLine("{");
            sw.WriteLine(TAB + "public interface I" + ast.baseName);
            sw.WriteLine(TAB + "{");

            DefineVisitor(sw, ast);

            //  Base Accept method
            sw.WriteLine();
            sw.WriteLine(TAB2 + VISITOR_FUNC + ";");
            sw.WriteLine();


            //  Gen AST Structs
            foreach (string t in ast.types)
            {
                string name = t.Split(":")[0].Trim();
                string fields = t.Split(":")[1].Trim();

                foreach (var def in ASTDefs)
                    fields = fields.Replace(def.baseName, "I" + def.baseName);

                DefineType(sw, ast.baseName, name, fields);
                sw.WriteLine();
            }

            sw.WriteLine(TAB + "}");
            sw.WriteLine("}");
        }

        private static void DefineVisitor(StreamWriter sw, (string baseName, string[] types) ast)
        {
            sw.WriteLine(TAB2 + "public interface IVisitor<T>");
            sw.WriteLine(TAB2 + "{");

            foreach(var t in ast.types)
            {
                var tName = t.Split(":")[0].Trim();
                sw.WriteLine(TAB3 + $"T Visit{tName}{ast.baseName}({tName} {ast.baseName.ToLower()});");
            }

            sw.WriteLine(TAB2 + "}");
        }

        static void DefineType(StreamWriter sw, string baseName, string name, string fieldList)
        {
            sw.WriteLine(TAB2 + $"public struct {name} : I{baseName}");
            sw.WriteLine(TAB2 + "{");
            
            //  Fields
            foreach(string f in fieldList.Split(", "))
                sw.WriteLine(TAB3 + "public " + f + ";");

            sw.WriteLine();
            
            //  Constructor
            sw.WriteLine(TAB3 + $"public {name}({fieldList})");
            sw.WriteLine(TAB3 + "{");

            foreach (string f in fieldList.Split(", "))
            {
                string fname = f.Split(" ")[1];
                sw.WriteLine(TAB4 + $"this.{fname} = {fname};");
            }

            sw.WriteLine(TAB3 + "}");


            sw.WriteLine();
            sw.WriteLine(TAB3 + "public " + VISITOR_FUNC);
            sw.WriteLine(TAB3 + "{");

            sw.WriteLine(TAB4 + "return visitor.Visit" + name + baseName + "(this);");
            
            sw.WriteLine(TAB3 + "}");

            sw.WriteLine(TAB2 + "}");
        }
    }
}



